#!/usr/bin/env python3

import argparse
import os
import signal
import shlex
from subprocess import Popen, PIPE, STDOUT
import tkinter as tk


def display(process_gpid, tail_process, app_name):
    # update the data in the window
    def update():

        # generator to read the data one line at a time
        def helper():
            for line in tail_process.stdout:
                line = line.decode('utf-8').strip()
                if app_name in line:
                    yield line

        result = helper()

        data = next(result)
        data = data.split(",")
        received, sent = round(int(data[2])/128,2), round(int(data[3])/128, 2)
        label['text'] = "Rx = {} Kbps \n Tx = {} Kbps".format(received, sent)
        window.after(1000, update)

    # display settings
    window = tk.Tk()
    label = tk.Label(window)
    label.pack()
    window.title("Rx/Tx Monitor")

    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()
    window_width = 200
    window_height = 50

    # launch the UI for the first time.
    update()

    # window position
    window.geometry(f'{window_width}x{window_height}+{screen_width-window_width}+{screen_height-window_height}')

    # block the program, if program is not blocked the process group will be killed 
    window.mainloop()

    # killing the process group ensures that the tail process is closed 
    # along with the nettop process when the tkinter window is closed.
    os.killpg(process_gpid, signal.SIGTERM)


def start_nettop(app_name):
    filename = "rxtx.log"
    log_file = open(filename, "w")

    # start nettop process
    nettop_cmd = "nettop -x -P -J bytes_in,bytes_out -d -L 0 "
    nettop_process = Popen(shlex.split(nettop_cmd), stdout=log_file, text=True)

    # start tail process
    tail_stdout_cmd = "tail -f %s" % filename
    tail_process = Popen(shlex.split(tail_stdout_cmd), stdin=PIPE, stdout=PIPE, stderr=STDOUT)

    # the nettop process and tail process belong to the same process group. killing the process
    # group terminates both the nettop and tail processes.
    pgid = os.getpgid(nettop_process.pid)
    print("Process Group ID = %s" % pgid)

    display(pgid, tail_process, app_name)


def main():
    parser = argparse.ArgumentParser(description='A tool to monitor network traffic over Workplace Chat and Zoom.')
    parser.add_argument('-a', '--app', type=str, default='chat', help='Specify chat or zoom to monitor Workplace Chat or Zoom respectively. Workplace Chat is the default.')
    args = parser.parse_args()

    if args.app in ['chat', '']:
        start_nettop('Workplace Chat')
    elif args.app == 'zoom':
        start_nettop('zoom.us')
    else:
        print('Invalid application specified. Valid values are chat or zoom.')


main()
